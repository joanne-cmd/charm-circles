/**
 * JoinCircleService - Handles joining a circle flow
 */

import { CircleInfo } from "./CircleService";

const API_BASE_URL = import.meta.env.VITE_API_URL || "http://localhost:3001";

export interface JoinCircleParams {
    circle: CircleInfo;
    newMemberPubkey: string; // hex-encoded
    payoutRound: number;
    circleAddress: string;
    fundingUtxo: string;
    fundingUtxoValue: number;
    changeAddress: string;
}

export interface JoinCircleResult {
    psbt: string;
    spellYaml: string;
}

export class JoinCircleService {
    /**
     * Build join spell and generate PSBT
     */
    async prepareJoinCircle(
        params: JoinCircleParams
    ): Promise<JoinCircleResult> {
        // Get previous transaction for circle UTXO
        const prevTxs = await this.getPreviousTransaction(params.circle.utxo);

        // Get app VK and build app binary path
        const appVk = await this.getAppVk();
        const appBin = "./target/wasm32-wasip1/release/charmcircle.wasm";

        // Calculate app_id from circle UTXO
        const appId = await this.calculateAppId(params.circle.utxo);

        // Get current circle state data
        // For example circles, we can't get real state, so we'll let the backend handle it
        // For real circles, the backend should extract it from the UTXO
        // If the circle has stateData, use it; otherwise let backend fetch it
        const prevCircleStateData = (params.circle as any).stateData || ""; // Try to get from circle info if available

        // Build parameters for join spell
        const spellParams = {
            app_id: appId,
            app_vk: appVk,
            circle_utxo: params.circle.utxo,
            prev_circle_state_data: prevCircleStateData,
            new_member_pubkey_hex: params.newMemberPubkey,
            payout_round: params.payoutRound.toString(),
            joined_at_timestamp: Math.floor(Date.now() / 1000).toString(),
            circle_address: params.circleAddress,
            // Updated state will be generated by the backend
            updated_circle_state_data: "", // Will be generated
        };

        // Call backend to build and prove spell
        const response = await fetch(
            `${API_BASE_URL}/api/spells/build-and-prove`,
            {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                },
                body: JSON.stringify({
                    templateName: "join-circle",
                    parameters: spellParams,
                    appBin,
                    prevTxs,
                    fundingUtxo: params.fundingUtxo,
                    fundingUtxoValue: params.fundingUtxoValue,
                    changeAddress: params.changeAddress,
                }),
            }
        );

        if (!response.ok) {
            const error = await response.json();
            throw new Error(
                error.error?.message || "Failed to prepare join transaction"
            );
        }

        const data = await response.json();
        return {
            psbt: data.data.proveResult.psbt,
            spellYaml: data.data.spellYaml,
        };
    }

    /**
     * Get previous transaction hex for UTXO
     */
    private async getPreviousTransaction(_utxo: string): Promise<string> {
        // This would typically call bitcoin-cli or an indexer API
        // For now, return empty - the backend should handle this
        return "";
    }

    /**
     * Get app verification key
     */
    private async getAppVk(): Promise<string> {
        await fetch(`${API_BASE_URL}/api/spells/templates`);
        // App VK should be available from backend or calculated
        // For now, return empty - this should be fetched from backend
        return "";
    }

    /**
     * Calculate app_id from UTXO
     */
    private async calculateAppId(utxo: string): Promise<string> {
        // SHA256 of UTXO string
        const encoder = new TextEncoder();
        const data = encoder.encode(utxo);
        const hashBuffer = await crypto.subtle.digest("SHA-256", data);
        const hashArray = Array.from(new Uint8Array(hashBuffer));
        return hashArray.map((b) => b.toString(16).padStart(2, "0")).join("");
    }
}
